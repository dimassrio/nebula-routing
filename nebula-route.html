<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../nebula-element-mixin/nebula-element-mixin.html">
<link rel="import" href="url-pattern.html">

<script>
(function() {
  'use strict'

  // symbols for private members
  const matchPath = Symbol()

  // symbols for protected members
  const observe = Symbol.for('Nebula.ElementMixin.observe')

  class NebulaRoute extends Nebula.ElementMixin(Polymer.Element) {

    /**
     * Gets the custom element name.
     * @type {string}
     */
    static get is() { return 'nebula-route' }

    /**
     * Gets the property definitions for data binding.
     * @type {Object}
     * @property {string} path - A path to parse and evaluate against the route pattern.
     * @property {string} pattern - A pattern to evaluate against the current route path.
     * @property {Object} data - The parsed route data if the route was matched.
     */
    static get properties() {
      return {
        path: {
          type: String
        },
        pattern: {
          type: String,
          value: '*'
        },
        data: {
          type: Object,
          notify: true,
          readOnly: true
        }
      }
    }

    /**
     * Lifecycle callback invoked when a new element instance is created.
     */
    constructor() {
      super()
      this[observe]('path, pattern', this[matchPath])
    }

    /**
     * Lifecycle callback handler triggered when data-binding initialization is complete.
     */
    ready() {
      super.ready();
      this.setAttribute('hidden', '')
    }

    /**
      * Parses the path and evaluates the pattern for a match.
      * @param {string} path The path to match against the current pattern.
      * @param {string} pattern The pattern to match.
      * @return {boolean} True if the path matches the pattern, otherwise false.
      * @private
    */
    [matchPath](path, pattern) {
      if (!(path && pattern)) return

      const parser = new UrlPattern(pattern)
      const match = parser.match(path)

      this._setData(match)
      return match
    }

    /** 
     * Evaluates the route target argument and generates a new URL.
     */
    getRouteUrl(target) {
      let url

      // create a url pattern parser so it can stringify
      // a proper url from parameters
      const parser = new UrlPattern(this.pattern)

      // if target is empty, then default stringify (all non-optional parts of pattern)
      // if target is a raw string, then just push it
      // if target is an object stringify with params
      if (!target) {
        url = parser.stringify()
      } else if (typeof target === 'string') {
        url = target
      } else if (typeof target === 'object') {
        url = parser.stringify(target)
      } else {
        const error = new Error('The redirect target argument is invalid')
        error.detail = target
        throw error
      }

      return url
    }

    /**
     * Changes the window location using the History API.
     * @param {string | Object} target - The target route.
     * @param {boolean} replace - Whether to push or replace the current path.
     */
    redirect(target, replace = false) {
      const url = this.getRouteUrl(target)

      // push or replace the browser location without a page refresh
      if (replace) {
        history.replaceState(null, null, url)
      } else {
        history.pushState(null, null, url)
      }

      // force a popstate event since default behavior is that
      // one is not fired on pushstate
      window.dispatchEvent(new PopStateEvent('popstate'))

      return url
    }

  }

  customElements.define(NebulaRoute.is, NebulaRoute)
}())
</script>